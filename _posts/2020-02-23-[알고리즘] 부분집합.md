---
layout : post
title : "[알고리즘] 부분집합"
data : 2020-02-23
author : 장성원
categories : 알고리즘
---

# 부분집합

부분집합이란 **주어진 집합에 포함되어 있는 집합**입니다.

예를 들어 집합 {1, 2, 3}이 있다고 가정하면 부분집합은 아래와 같습니다.

{1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}

배열 {1, 2, 3}의 부분 집합의 개수는 `공집합을 포함하지 않을 경우 7개이며, 공집합을 포함한다면 8개이다.`

즉 원소의 개수가 `n개`가 있다면 부분 집합의 수는 `2^n`개 입니다.

이는 각 원소를 부분 집합에 포함시키거나 포함시키 않는 `2가지`의 경우를 모든 원소에 적용한 경우의 수와 같습니다.

![subset1](/assets/image/subset_1.jpg)

<br>

<br>

## 부분집합 생성(1) 

대상 List 각 원소의 포함여부를 구분하여 간단하게 구현할 수 있습니다.

```python
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i					# 0번째 원소
    for j in range(2):
        bit[1] = j				# 1번째 원소
        for k in range(2):
            bit[2] = k			# 2번째 원소
            for l in range(2):
                bit[3] = l		# 3번째 원소
                print(bit)	
                
```

대상 List가 {1, 2, 3, 4}이면 위 코드의 결과를 아래와 같이 정리할 수 있습니다.

![subset1](/assets/image/subset_2.jpg)

<br>

<br>

## 부분집합 생성(2)

부분집합을 비트연산자를 이용하여 생성할 수 있습니다.

비트연산자는 &, ㅣ, <<. >> 4가지가 존재합니다.

| 종류 | 역할                                          |
| ---- | --------------------------------------------- |
| &    | 비트 단위로 AND 연산을 합니다.                |
| \|   | 비트 단위로 OR 연산을 합니다.                 |
| <<   | 피연산자의 비트 열을 왼쪽으로 이동시킵니다.   |
| >>   | 피연산자의 비트 열을 오른쪽으로 이동시킵니다. |



`1 << n`은 2^n을 의미하며 원소가 n개일 경우의 모든 부분 집합의 수를 의미합니다.

`i & (1<<j): 1`은 i에서 j번째 비트가 1인지 아닌지를 리턴합니다.

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr) # n은 원소의 개수를 의미합니다.

for i in range(1 << n): # 1<<n은 부분 집합의 개수를 의미합니다.
    for j in range(n): # 원소의 수 만큼 비트를 비교합니다.
        if i & (1 << j): # i의 j번째 비트가 1이면 j번째 원소를 출력합니다.
            print(arr[j], end=",")
    print()

```

<br>

<br>

## 응용

SW Expert Academy 부분집합의 합 문제



**[문제]**

1부터 12까지의 숫자를 원소로 가진 집합 A가 있다. 집합 A의 부분 집합 중 N개의 원소를 갖고 있고, 원소의 합이 K인 부분집합의 개수를 출력하는 프로그램을 작성하시오.

해당하는 부분집합이 없는 경우 0을 출력한다. 모든 부분 집합을 만들어 답을 찾아도 된다.

예를 들어 N = 3, K = 6 경우, 부분집합은 { 1, 2, 3 } 경우 1가지가 존재한다.

<br>

**[입력]**

첫 줄에 테스트 케이스 개수 T가 주어진다. ( 1 ≤ T ≤ 50 )

테스트 케이스 별로 부분집합 원소의 수 N과 부분 집합의 합 K가 여백을 두고 주어진다. ( 1 ≤ N ≤ 12, 1 ≤ K ≤ 100 )

 <br>

**[출력]**

각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.



```python
T = int(input())
for t in range(T):
    N, K = map(int, input().split())
    cnt = 0
    for i in range(1, 1 << 12):
        bitCnt = sum = 0
        for j in range(12):
            if i & (1 << j):
                sum += j+1
                bitCnt += 1
        if sum == K and bitCnt == N:
            cnt += 1
    print('#{0} {1}'.format(t+1, cnt))
```

<br>

<br>

## 정리

부분 집합에 대해서는 의미정도만 알고있었다.

따라서 부분 집합과 관련된 알고리즘 문제가 나오면 머리로는 이해가 가는데 코드 작성에 어려움이 있었다.

직접적인 부분 집합 문제말고도 다른 문제에도 응용이 충분히 가능할 것 같으며 후에 많은 도움이 될 것 같다.

<br>

읽기 불편하거나, 틀린점이 있다면 알려주시면 감사하겠습니다!

읽어주셔서 감사합니다.